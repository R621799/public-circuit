<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shoe Generator - Rack & Pinion Energy Harvesting Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            overflow: hidden;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            min-width: 280px;
            z-index: 100;
        }
        
        h1 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #1e3c72;
            border-bottom: 2px solid #2a5298;
            padding-bottom: 8px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
            font-weight: 600;
            color: #333;
        }
        
        button {
            width: 100%;
            padding: 12px;
            margin: 5px 0;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        #press-pedal {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        #press-pedal:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        #press-pedal:active {
            transform: translateY(0);
        }
        
        #reset {
            background: #f39c12;
            color: white;
        }
        
        #reset:hover {
            background: #e67e22;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(243, 156, 18, 0.4);
        }
        
        input[type="range"] {
            width: 100%;
            margin: 8px 0;
        }
        
        .info-display {
            background: #ecf0f1;
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 12px;
        }
        
        .info-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 3px 0;
        }
        
        .info-label {
            font-weight: 600;
            color: #555;
        }
        
        .info-value {
            color: #2a5298;
            font-weight: 700;
        }
        
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            font-size: 12px;
            max-width: 280px;
            z-index: 100;
        }
        
        #info h3 {
            font-size: 14px;
            margin-bottom: 8px;
            color: #1e3c72;
        }
        
        #info p {
            margin: 5px 0;
            line-height: 1.4;
            color: #555;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="controls">
        <h1>‚ö° Shoe Generator Control</h1>
        
        <div class="control-group">
            <button id="press-pedal">Press Foot Pedal</button>
            <button id="reset">Reset Simulation</button>
        </div>
        
        <div class="control-group">
            <label for="speed">Compression Speed:</label>
            <input type="range" id="speed" min="1" max="10" value="5" step="1">
            <span id="speed-value">5</span>
        </div>
        
        <div class="info-display">
            <div class="info-item">
                <span class="info-label">Electrons Generated:</span>
                <span class="info-value" id="electron-count">0</span>
            </div>
            <div class="info-item">
                <span class="info-label">Motor RPM:</span>
                <span class="info-value" id="motor-rpm">0</span>
            </div>
            <div class="info-item">
                <span class="info-label">Current Output:</span>
                <span class="info-value" id="current">0 mA</span>
            </div>
        </div>
    </div>
    
    <div id="info">
        <h3>How It Works:</h3>
        <p><strong>1. Foot Compression:</strong> Pressing the pedal pushes the rack downward.</p>
        <p><strong>2. Rack & Pinion:</strong> Vertical rack teeth mesh with pinion gear.</p>
        <p><strong>3. Gear Train:</strong> Bevel gears convert vertical to horizontal rotation.</p>
        <p><strong>4. Motor Generation:</strong> Horizontal motor generates AC electricity.</p>
        <p><strong>5. Electron Flow:</strong> Yellow spheres show electron movement.</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ============================================
        // SCENE SETUP
        // ============================================
        
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(10, 8, 10);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        // ============================================
        // LIGHTING
        // ============================================
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);
        
        const pointLight = new THREE.PointLight(0x4a90e2, 0.5);
        pointLight.position.set(-5, 5, 5);
        scene.add(pointLight);
        
        // ============================================
        // MATERIALS
        // ============================================
        
        const pedalMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x34495e,
            metalness: 0.3,
            roughness: 0.7
        });
        
        const rackMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x7f8c8d,
            metalness: 0.6,
            roughness: 0.4
        });
        
        const pinionMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xe74c3c,
            metalness: 0.7,
            roughness: 0.3
        });
        
        const bevelGearMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xe67e22,
            metalness: 0.7,
            roughness: 0.3
        });
        
        const motorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x2c3e50,
            metalness: 0.8,
            roughness: 0.2
        });
        
        const wireMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x95a5a6,
            metalness: 0.5,
            roughness: 0.5
        });
        
        const electronMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xffff00,
            emissive: 0xffff00,
            emissiveIntensity: 0.5,
            metalness: 0.1,
            roughness: 0.3
        });
        
        const shaftMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x7f8c8d,
            metalness: 0.9,
            roughness: 0.1
        });
        
        // ============================================
        // HELPER FUNCTIONS FOR GEAR CREATION
        // ============================================
        
        function createDetailedRackTooth(width, height, depth) {
            const shape = new THREE.Shape();
            
            // Tooth profile (trapezoidal for realistic gear teeth)
            const topWidth = width * 0.6;
            const bottomWidth = width;
            
            shape.moveTo(-bottomWidth/2, 0);
            shape.lineTo(-topWidth/2, height);
            shape.lineTo(topWidth/2, height);
            shape.lineTo(bottomWidth/2, 0);
            shape.lineTo(-bottomWidth/2, 0);
            
            const extrudeSettings = {
                depth: depth,
                bevelEnabled: true,
                bevelThickness: 0.02,
                bevelSize: 0.02,
                bevelSegments: 2
            };
            
            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            geometry.rotateX(Math.PI / 2);
            geometry.translate(0, 0, -depth / 2);
            
            return geometry;
        }
        
        function createPinionGear(radius, thickness, numTeeth) {
            const group = new THREE.Group();
            
            // Main gear body
            const bodyGeometry = new THREE.CylinderGeometry(radius * 0.85, radius * 0.85, thickness, 32);
            const body = new THREE.Mesh(bodyGeometry, pinionMaterial);
            body.rotation.z = Math.PI / 2;
            body.castShadow = true;
            group.add(body);
            
            // Gear teeth
            const toothHeight = radius * 0.25;
            const toothWidth = (2 * Math.PI * radius) / numTeeth * 0.7;
            
            for (let i = 0; i < numTeeth; i++) {
                const angle = (i / numTeeth) * Math.PI * 2;
                const toothGeometry = new THREE.BoxGeometry(toothWidth, thickness, toothHeight);
                const tooth = new THREE.Mesh(toothGeometry, pinionMaterial);
                
                const toothRadius = radius + toothHeight / 2;
                tooth.position.set(
                    0,
                    Math.cos(angle) * toothRadius,
                    Math.sin(angle) * toothRadius
                );
                tooth.rotation.y = angle;
                tooth.castShadow = true;
                group.add(tooth);
            }
            
            return group;
        }
        
        function createBevelGear(radius, thickness, numTeeth, isDriver = true) {
            const group = new THREE.Group();
            
            // Main conical body
            const coneRadius1 = isDriver ? radius : radius * 0.9;
            const coneRadius2 = isDriver ? radius * 0.7 : radius * 0.6;
            const bodyGeometry = new THREE.CylinderGeometry(coneRadius1, coneRadius2, thickness, 32);
            const body = new THREE.Mesh(bodyGeometry, bevelGearMaterial);
            body.castShadow = true;
            group.add(body);
            
            // Bevel gear teeth (angled)
            const toothHeight = radius * 0.2;
            const toothWidth = (2 * Math.PI * radius) / numTeeth * 0.6;
            
            for (let i = 0; i < numTeeth; i++) {
                const angle = (i / numTeeth) * Math.PI * 2;
                const toothGeometry = new THREE.BoxGeometry(toothWidth, thickness * 0.8, toothHeight);
                const tooth = new THREE.Mesh(toothGeometry, bevelGearMaterial);
                
                const toothRadius = radius + toothHeight / 2;
                tooth.position.set(
                    Math.cos(angle) * toothRadius,
                    0,
                    Math.sin(angle) * toothRadius
                );
                tooth.rotation.y = angle;
                tooth.castShadow = true;
                group.add(tooth);
            }
            
            return group;
        }
        
        // ============================================
        // COMPONENTS
        // ============================================
        
        // Base Platform
        const baseGeometry = new THREE.BoxGeometry(8, 0.3, 8);
        const baseMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x2c3e50,
            metalness: 0.4,
            roughness: 0.6
        });
        const base = new THREE.Mesh(baseGeometry, baseMaterial);
        base.position.y = -2;
        base.receiveShadow = true;
        scene.add(base);
        
        // Foot Pedal
        const pedalGeometry = new THREE.BoxGeometry(2.5, 0.4, 2.5);
        const pedal = new THREE.Mesh(pedalGeometry, pedalMaterial);
        pedal.position.set(0, 2, 0);
        pedal.castShadow = true;
        scene.add(pedal);
        
        // Support column for pedal
        const columnGeometry = new THREE.CylinderGeometry(0.15, 0.15, 1, 16);
        const column = new THREE.Mesh(columnGeometry, new THREE.MeshStandardMaterial({ 
            color: 0x34495e,
            metalness: 0.5,
            roughness: 0.6
        }));
        column.position.set(0, 1.5, 0);
        column.castShadow = true;
        scene.add(column);
        
        // Rack (vertical bar with detailed teeth)
        const rackGroup = new THREE.Group();
        
        // Main rack body
        const rackBodyGeometry = new THREE.BoxGeometry(0.5, 3.5, 0.6);
        const rackBody = new THREE.Mesh(rackBodyGeometry, rackMaterial);
        rackBody.castShadow = true;
        rackGroup.add(rackBody);
        
        // Detailed rack teeth
        const numTeeth = 18;
        const toothGeometry = createDetailedRackTooth(0.25, 0.2, 0.6);
        
        for (let i = 0; i < numTeeth; i++) {
            const tooth = new THREE.Mesh(toothGeometry, rackMaterial);
            tooth.position.set(0.35, -1.75 + (i * 0.195), 0);
            tooth.castShadow = true;
            rackGroup.add(tooth);
        }
        
        rackGroup.position.set(-2.5, 0.5, 0);
        scene.add(rackGroup);
        
        // Vertical Pinion Gear (meshes with rack)
        const verticalPinionGroup = createPinionGear(0.9, 0.7, 20);
        verticalPinionGroup.position.set(-1.25, 0.5, 0);
        scene.add(verticalPinionGroup);
        
        // Vertical shaft from pinion to bevel gear
        const verticalShaftGeometry = new THREE.CylinderGeometry(0.12, 0.12, 2.5, 16);
        const verticalShaft = new THREE.Mesh(verticalShaftGeometry, shaftMaterial);
        verticalShaft.position.set(-1.25, -0.75, 0);
        verticalShaft.castShadow = true;
        scene.add(verticalShaft);
        
        // Driver Bevel Gear (on vertical shaft)
        const driverBevelGear = createBevelGear(0.8, 0.6, 16, true);
        driverBevelGear.position.set(-1.25, -1.8, 0);
        scene.add(driverBevelGear);
        
        // Driven Bevel Gear (on horizontal shaft, meshes at 90 degrees)
        const drivenBevelGear = createBevelGear(0.8, 0.6, 16, false);
        drivenBevelGear.rotation.x = Math.PI / 2;
        drivenBevelGear.position.set(-1.25, -1.8, 0.8);
        scene.add(drivenBevelGear);
        
        // Horizontal shaft to motor
        const horizontalShaftGeometry = new THREE.CylinderGeometry(0.12, 0.12, 3, 16);
        const horizontalShaft = new THREE.Mesh(horizontalShaftGeometry, shaftMaterial);
        horizontalShaft.rotation.z = Math.PI / 2;
        horizontalShaft.position.set(0.25, -1.8, 0.8);
        horizontalShaft.castShadow = true;
        scene.add(horizontalShaft);
        
        // Intermediate Gear (increases speed)
        const intermediateGearGroup = createPinionGear(0.6, 0.5, 12);
        intermediateGearGroup.rotation.y = Math.PI / 2;
        intermediateGearGroup.position.set(1, -1.8, 0.8);
        scene.add(intermediateGearGroup);
        
        // Final shaft section to motor
        const finalShaftGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1.5, 16);
        const finalShaft = new THREE.Mesh(finalShaftGeometry, shaftMaterial);
        finalShaft.rotation.z = Math.PI / 2;
        finalShaft.position.set(2, -1.8, 0.8);
        finalShaft.castShadow = true;
        scene.add(finalShaft);
        
        // Motor (BLDC Generator) - Horizontal orientation
        const motorGroup = new THREE.Group();
        
        // Motor housing
        const motorBodyGeometry = new THREE.CylinderGeometry(0.7, 0.7, 1.8, 32);
        const motorBody = new THREE.Mesh(motorBodyGeometry, motorMaterial);
        motorBody.rotation.z = Math.PI / 2;
        motorBody.castShadow = true;
        motorGroup.add(motorBody);
        
        // Motor end caps
        const endCapGeometry = new THREE.CylinderGeometry(0.75, 0.75, 0.15, 32);
        const endCap1 = new THREE.Mesh(endCapGeometry, new THREE.MeshStandardMaterial({ 
            color: 0x95a5a6,
            metalness: 0.8,
            roughness: 0.3
        }));
        endCap1.rotation.z = Math.PI / 2;
        endCap1.position.x = 0.9;
        endCap1.castShadow = true;
        motorGroup.add(endCap1);
        
        const endCap2 = endCap1.clone();
        endCap2.position.x = -0.9;
        motorGroup.add(endCap2);
        
        // Motor cooling fins
        for (let i = 0; i < 8; i++) {
            const finGeometry = new THREE.BoxGeometry(1.8, 0.08, 0.08);
            const fin = new THREE.Mesh(finGeometry, new THREE.MeshStandardMaterial({ 
                color: 0x34495e,
                metalness: 0.6,
                roughness: 0.4
            }));
            const angle = (i / 8) * Math.PI * 2;
            fin.position.y = Math.cos(angle) * 0.72;
            fin.position.z = Math.sin(angle) * 0.72;
            fin.castShadow = true;
            motorGroup.add(fin);
        }
        
        motorGroup.position.set(2.75, -1.8, 0.8);
        scene.add(motorGroup);
        
        // Motor mounting bracket
        const bracketGeometry = new THREE.BoxGeometry(0.3, 1.2, 1.2);
        const bracket = new THREE.Mesh(bracketGeometry, new THREE.MeshStandardMaterial({ 
            color: 0x7f8c8d,
            metalness: 0.5,
            roughness: 0.5
        }));
        bracket.position.set(2.75, -1.8, 0.8);
        bracket.castShadow = true;
        scene.add(bracket);
        
        // Wire Path (from motor)
        const wireCurve = new THREE.CatmullRomCurve3([
            new THREE.Vector3(2.75, -1.8, 1.5),    // Start at motor top
            new THREE.Vector3(2.5, -1, 2),         // Curve up and out
            new THREE.Vector3(2, 0, 2.5),          // Continue curve
            new THREE.Vector3(1.5, 1, 3),          // Rise more
            new THREE.Vector3(1, 1.5, 3.5),        // Peak
            new THREE.Vector3(0.5, 1.8, 4)         // Extended end
        ]);
        
        const wireTubeGeometry = new THREE.TubeGeometry(wireCurve, 64, 0.06, 8, false);
        const wire = new THREE.Mesh(wireTubeGeometry, wireMaterial);
        wire.castShadow = true;
        scene.add(wire);
        
        // ============================================
        // ELECTRONS (Yellow Spheres)
        // ============================================
        
        const electrons = [];
        const maxElectrons = 25;
        
        function createElectron() {
            const electronGeometry = new THREE.SphereGeometry(0.12, 16, 16);
            const electron = new THREE.Mesh(electronGeometry, electronMaterial.clone());
            electron.castShadow = true;
            electron.userData.progress = 0;
            electron.userData.active = false;
            scene.add(electron);
            return electron;
        }
        
        // Pre-create electron pool
        for (let i = 0; i < maxElectrons; i++) {
            electrons.push(createElectron());
        }
        
        // ============================================
        // ANIMATION STATE
        // ============================================
        
        const state = {
            pedalPressed: false,
            pedalPosition: 2,
            targetPedalPosition: 2,
            rackPosition: 0.5,
            verticalPinionRotation: 0,
            driverBevelRotation: 0,
            drivenBevelRotation: 0,
            intermediateGearRotation: 0,
            motorRotation: 0,
            motorSpeed: 0,
            compressionSpeed: 5,
            electronCount: 0,
            activeElectrons: 0,
            isAnimating: false
        };
        
        // ============================================
        // PHYSICS CALCULATIONS
        // ============================================
        
        const pinionRadius = 0.9;
        const bevelGearRatio = 1.0; // 1:1 for bevel gears (90-degree direction change)
        const intermediateGearRatio = 1.5; // Intermediate gear spins 1.5x faster
        const totalGearRatio = bevelGearRatio * intermediateGearRatio;
        
        function updatePhysics() {
            // Update pedal position with smooth interpolation
            const lerpFactor = 0.1 * state.compressionSpeed;
            state.pedalPosition += (state.targetPedalPosition - state.pedalPosition) * lerpFactor;
            pedal.position.y = state.pedalPosition;
            column.scale.y = state.pedalPosition / 2;
            column.position.y = state.pedalPosition / 2;
            
            // Calculate rack displacement from pedal
            const rackDisplacement = 2 - state.pedalPosition;
            state.rackPosition = 0.5 - rackDisplacement;
            rackGroup.position.y = state.rackPosition;
            
            // Convert linear rack motion to vertical pinion rotation
            const linearDistance = rackDisplacement;
            const pinionRotationDelta = linearDistance / pinionRadius;
            state.verticalPinionRotation = pinionRotationDelta;
            verticalPinionGroup.rotation.y = state.verticalPinionRotation;
            
            // Driver bevel gear rotates with vertical pinion
            state.driverBevelRotation = state.verticalPinionRotation;
            driverBevelGear.rotation.y = state.driverBevelRotation;
            
            // Driven bevel gear (90-degree transfer)
            state.drivenBevelRotation = state.driverBevelRotation * bevelGearRatio;
            drivenBevelGear.rotation.z = state.drivenBevelRotation;
            
            // Intermediate gear increases speed
            state.intermediateGearRotation = state.drivenBevelRotation * intermediateGearRatio;
            intermediateGearGroup.rotation.x = state.intermediateGearRotation;
            
            // Motor rotates at final gear ratio
            state.motorRotation = state.drivenBevelRotation * totalGearRatio;
            motorGroup.rotation.x = state.motorRotation;
            
            // Calculate motor RPM
            const rotationsPerFrame = Math.abs(state.motorSpeed);
            state.motorRPM = Math.round(rotationsPerFrame * 60 * 60);
            
            // Current output scales with motor speed
            const currentOutput = Math.round(Math.abs(state.motorSpeed) * 150);
            
            // Update UI
            document.getElementById('motor-rpm').textContent = state.motorRPM;
            document.getElementById('current').textContent = currentOutput + ' mA';
        }
        
        // ============================================
        // ELECTRON FLOW ANIMATION
        // ============================================
        
        function updateElectrons(deltaTime) {
            // Generate new electrons when motor is spinning
            if (state.motorSpeed > 0.001 && state.activeElectrons < maxElectrons) {
                const electronSpawnRate = state.motorSpeed * 8;
                if (Math.random() < electronSpawnRate * deltaTime) {
                    spawnElectron();
                }
            }
            
            // Update existing electrons
            electrons.forEach(electron => {
                if (!electron.userData.active) return;
                
                // Move electron along wire curve
                electron.userData.progress += state.motorSpeed * 0.4 * deltaTime * 60;
                
                if (electron.userData.progress >= 1) {
                    // Electron reached end of wire
                    electron.userData.active = false;
                    electron.visible = false;
                    state.activeElectrons--;
                } else {
                    // Update position along curve
                    const point = wireCurve.getPoint(electron.userData.progress);
                    electron.position.copy(point);
                    
                    // Pulse effect
                    const pulse = 1 + Math.sin(Date.now() * 0.01 + electron.userData.progress * 10) * 0.3;
                    electron.scale.setScalar(pulse);
                    
                    // Color intensity based on speed
                    const intensity = 0.3 + state.motorSpeed * 10;
                    electron.material.emissiveIntensity = Math.min(intensity, 1);
                }
            });
        }
        
        function spawnElectron() {
            const electron = electrons.find(e => !e.userData.active);
            if (!electron) return;
            
            electron.userData.active = true;
            electron.userData.progress = 0;
            electron.visible = true;
            state.activeElectrons++;
            state.electronCount++;
            
            document.getElementById('electron-count').textContent = state.electronCount;
        }
        
        // ============================================
        // CONTROLS
        // ============================================
        
        document.getElementById('press-pedal').addEventListener('click', () => {
            if (state.pedalPressed) {
                state.targetPedalPosition = 2;
                state.pedalPressed = false;
                document.getElementById('press-pedal').textContent = 'Press Foot Pedal';
            } else {
                state.targetPedalPosition = 0.2;
                state.pedalPressed = true;
                state.isAnimating = true;
                document.getElementById('press-pedal').textContent = 'Release Pedal';
            }
        });
        
        document.getElementById('reset').addEventListener('click', () => {
            state.pedalPressed = false;
            state.targetPedalPosition = 2;
            state.pedalPosition = 2;
            state.rackPosition = 0.5;
            state.verticalPinionRotation = 0;
            state.driverBevelRotation = 0;
            state.drivenBevelRotation = 0;
            state.intermediateGearRotation = 0;
            state.motorRotation = 0;
            state.motorSpeed = 0;
            state.electronCount = 0;
            state.activeElectrons = 0;
            state.isAnimating = false;
            
            electrons.forEach(electron => {
                electron.userData.active = false;
                electron.visible = false;
            });
            
            document.getElementById('electron-count').textContent = '0';
            document.getElementById('motor-rpm').textContent = '0';
            document.getElementById('current').textContent = '0 mA';
            document.getElementById('press-pedal').textContent = 'Press Foot Pedal';
        });
        
        document.getElementById('speed').addEventListener('input', (e) => {
            state.compressionSpeed = parseInt(e.target.value);
            document.getElementById('speed-value').textContent = e.target.value;
        });
        
        // ============================================
        // ANIMATION LOOP
        // ============================================
        
        let lastTime = Date.now();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const currentTime = Date.now();
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            // Calculate motor angular velocity
            const oldMotorRotation = motorGroup.rotation.x;
            updatePhysics();
            const newMotorRotation = motorGroup.rotation.x;
            state.motorSpeed = Math.abs(newMotorRotation - oldMotorRotation);
            
            // Decay motor speed when pedal is released
            if (!state.pedalPressed && state.motorSpeed > 0.001) {
                state.motorSpeed *= 0.95;
            } else if (!state.pedalPressed && state.motorSpeed <= 0.001) {
                state.motorSpeed = 0;
            }
            
            // Update electron flow
            updateElectrons(deltaTime);
            
            // Auto-rotate camera
            const time = Date.now() * 0.0001;
            camera.position.x = Math.cos(time) * 10;
            camera.position.z = Math.sin(time) * 10;
            camera.lookAt(0, -0.5, 0);
            
            renderer.render(scene, camera);
        }
        
        // ============================================
        // WINDOW RESIZE HANDLER
        // ============================================
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Start animation
        animate();
        
        // ============================================
        // CONSOLE INFO
        // ============================================
        
        console.log('üîå Enhanced Shoe Generator Simulation Loaded');
        console.log('üìê Physics Model:');
        console.log('  - Vertical Pinion Radius:', pinionRadius, 'units');
        console.log('  - Bevel Gear Ratio:', bevelGearRatio + ':1 (90¬∞ turn)');
        console.log('  - Intermediate Gear Ratio:', intermediateGearRatio + ':1');
        console.log('  - Total Gear Ratio:', totalGearRatio + ':1');
        console.log('  - Rotation: Œ∏ = d / r');
        console.log('  - Power: P ‚àù œâ¬≤');
    </script>
</body>
</html>