<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shoe Generator - 3D Engineering Simulation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', sans-serif;
            background: #1a1a2e;
            overflow: hidden;
        }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        #controls {
            position: absolute; top: 20px; left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px; border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            min-width: 280px; z-index: 100;
        }
        h1 { font-size: 18px; margin-bottom: 15px; color: #1e3c72; border-bottom: 2px solid #2a5298; padding-bottom: 8px; }
        .control-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-size: 13px; font-weight: 600; color: #333; }
        button {
            width: 100%; padding: 12px; margin: 5px 0; border: none;
            border-radius: 6px; font-size: 14px; font-weight: 600;
            cursor: pointer; transition: all 0.3s ease; text-transform: uppercase;
        }
        #press-pedal { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
        #reset { background: #f39c12; color: white; }
        input[type="range"] { width: 100%; margin: 8px 0; }
        .info-display { background: #ecf0f1; padding: 10px; border-radius: 6px; margin-top: 10px; font-size: 12px; }
        .info-item { display: flex; justify-content: space-between; margin: 5px 0; }
        .info-value { color: #2a5298; font-weight: 700; }
        #info {
            position: absolute; bottom: 20px; left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px; border-radius: 12px;
            max-width: 280px; font-size: 12px; z-index: 100;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="controls">
        <h1>⚡ Shoe Generator Control</h1>
        <div class="control-group">
            <button id="press-pedal">Press Foot Pedal</button>
            <button id="reset">Reset Simulation</button>
        </div>
        <div class="control-group">
            <label for="speed">Compression Speed:</label>
            <input type="range" id="speed" min="1" max="10" value="5" step="1">
            <span id="speed-value">5</span>
        </div>
        <div class="info-display">
            <div class="info-item"><span>Electrons Generated:</span><span class="info-value" id="electron-count">0</span></div>
            <div class="info-item"><span>Motor RPM:</span><span class="info-value" id="motor-rpm">0</span></div>
            <div class="info-item"><span>Current Output:</span><span class="info-value" id="current">0 mA</span></div>
        </div>
    </div>

    <div id="info">
        <h3>User Interaction:</h3>
        <p>• <strong>Left Click + Drag:</strong> Rotate Model</p>
        <p>• <strong>Right Click + Drag:</strong> Pan View</p>
        <p>• <strong>Scroll:</strong> Zoom In/Out</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(8, 6, 8);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- ORBIT CONTROLS (NEW) ---
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // --- LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // --- COMPONENTS ---
        const base = new THREE.Mesh(new THREE.BoxGeometry(6, 0.3, 6), new THREE.MeshStandardMaterial({ color: 0x2c3e50 }));
        base.position.y = -2;
        scene.add(base);

        const pedal = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.4, 2.5), new THREE.MeshStandardMaterial({ color: 0x34495e }));
        pedal.position.y = 2;
        scene.add(pedal);

        // Rack Group
        const rackGroup = new THREE.Group();
        const rackBody = new THREE.Mesh(new THREE.BoxGeometry(0.4, 3, 0.8), new THREE.MeshStandardMaterial({ color: 0x7f8c8d }));
        rackGroup.add(rackBody);
        for (let i = 0; i < 12; i++) {
            const tooth = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.15, 0.8), new THREE.MeshStandardMaterial({ color: 0x7f8c8d }));
            tooth.position.set(0.3, -1.5 + (i * 0.25), 0);
            rackGroup.add(tooth);
        }
        rackGroup.position.set(-2, 0.5, 0);
        scene.add(rackGroup);

        // Pinion Gear Group (Rotating Part)
        const pinionGroup = new THREE.Group();
        const pinionBody = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 0.6, 32), new THREE.MeshStandardMaterial({ color: 0xe74c3c }));
        pinionBody.rotation.z = Math.PI / 2;
        pinionGroup.add(pinionBody);
        for (let i = 0; i < 16; i++) {
            const angle = (i / 16) * Math.PI * 2;
            const tooth = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.6, 0.2), new THREE.MeshStandardMaterial({ color: 0xe74c3c }));
            tooth.position.set(Math.cos(angle) * 0.9, 0, Math.sin(angle) * 0.9);
            tooth.rotation.y = angle;
            pinionGroup.add(tooth);
        }
        pinionGroup.position.set(-0.7, 0.5, 0);
        scene.add(pinionGroup);

        // STATIONARY SHAFT (MODIFIED: Not a child of Pinion)
        const shaftGeom = new THREE.CylinderGeometry(0.15, 0.15, 2.5, 16);
        const shaftMat = new THREE.MeshStandardMaterial({ color: 0x7f8c8d, metalness: 0.9 });
        const shaft = new THREE.Mesh(shaftGeom, shaftMat);
        shaft.rotation.z = Math.PI / 2;
        shaft.position.set(0.3, 0.5, 0); // Positioned between pinion and motor
        scene.add(shaft);

        // Motor
        const motorGroup = new THREE.Group();
        const motorBody = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 1.5, 32), new THREE.MeshStandardMaterial({ color: 0x2c3e50 }));
        motorBody.rotation.z = Math.PI / 2;
        motorGroup.add(motorBody);
        motorGroup.position.set(1.3, 0.5, 0);
        scene.add(motorGroup);

        // --- ELECTRONS & WIRE ---
        const wireCurve = new THREE.CatmullRomCurve3([
            new THREE.Vector3(1.3, 0.5, 0.6), new THREE.Vector3(1.5, 1, 1.5),
            new THREE.Vector3(2.5, 2.5, 3.5), new THREE.Vector3(3, 2.5, 4)
        ]);
        const wire = new THREE.Mesh(new THREE.TubeGeometry(wireCurve, 64, 0.05, 8, false), new THREE.MeshStandardMaterial({ color: 0x95a5a6 }));
        scene.add(wire);

        const electrons = [];
        const electronMat = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffff00 });
        for (let i = 0; i < 20; i++) {
            const e = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), electronMat);
            e.userData = { progress: 0, active: false };
            e.visible = false;
            scene.add(e);
            electrons.push(e);
        }

        // --- STATE & LOGIC ---
        const state = {
            pedalPressed: false, pedalPos: 2, targetPedalPos: 2,
            compSpeed: 5, motorSpeed: 0, electronCount: 0
        };

        document.getElementById('press-pedal').onclick = () => {
            state.pedalPressed = !state.pedalPressed;
            state.targetPedalPos = state.pedalPressed ? 0.2 : 2;
            document.getElementById('press-pedal').textContent = state.pedalPressed ? 'Release Pedal' : 'Press Foot Pedal';
        };

        document.getElementById('reset').onclick = () => location.reload();

        document.getElementById('speed').oninput = (e) => {
            state.compSpeed = e.target.value;
            document.getElementById('speed-value').textContent = e.target.value;
        };

        let lastTime = Date.now();
        function animate() {
            requestAnimationFrame(animate);
            const delta = (Date.now() - lastTime) / 1000;
            lastTime = Date.now();

            // Physics Update
            const oldRot = pinionGroup.rotation.y;
            state.pedalPos += (state.targetPedalPos - state.pedalPos) * 0.1 * state.compSpeed;
            pedal.position.y = state.pedalPos;
            rackGroup.position.y = 0.5 - (2 - state.pedalPos);
            pinionGroup.rotation.y = (2 - state.pedalPos) / 0.8;
            motorGroup.rotation.x = pinionGroup.rotation.y * 5;
            state.motorSpeed = Math.abs(pinionGroup.rotation.y - oldRot);

            // Electron Logic
            if (state.motorSpeed > 0.001) {
                if (Math.random() < state.motorSpeed * 5) {
                    const e = electrons.find(el => !el.userData.active);
                    if (e) { e.userData.active = true; e.userData.progress = 0; e.visible = true; state.electronCount++; }
                }
            }
            electrons.forEach(e => {
                if (e.userData.active) {
                    e.userData.progress += 0.02;
                    if (e.userData.progress >= 1) { e.userData.active = false; e.visible = false; }
                    else { e.position.copy(wireCurve.getPoint(e.userData.progress)); }
                }
            });

            // UI
            document.getElementById('electron-count').textContent = state.electronCount;
            document.getElementById('motor-rpm').textContent = Math.round(state.motorSpeed * 3600);
            document.getElementById('current').textContent = Math.round(state.motorSpeed * 100) + ' mA';

            controls.update(); // Update OrbitControls
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>