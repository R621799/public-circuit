<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shoe Generator - Zero Dependency Version</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            overflow: hidden;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            min-width: 280px;
            z-index: 100;
        }
        
        h1 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #1e3c72;
            border-bottom: 2px solid #2a5298;
            padding-bottom: 8px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
            font-weight: 600;
            color: #333;
        }
        
        button {
            width: 100%;
            padding: 12px;
            margin: 5px 0;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        #press-pedal {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        #press-pedal:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        #press-pedal:active {
            transform: translateY(0);
        }
        
        #reset {
            background: #f39c12;
            color: white;
        }
        
        #reset:hover {
            background: #e67e22;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(243, 156, 18, 0.4);
        }
        
        input[type="range"] {
            width: 100%;
            margin: 8px 0;
        }
        
        .info-display {
            background: #ecf0f1;
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 12px;
        }
        
        .info-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 3px 0;
        }
        
        .info-label {
            font-weight: 600;
            color: #555;
        }
        
        .info-value {
            color: #2a5298;
            font-weight: 700;
        }
        
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            font-size: 12px;
            max-width: 280px;
            z-index: 100;
        }
        
        #info h3 {
            font-size: 14px;
            margin-bottom: 8px;
            color: #1e3c72;
        }
        
        #info p {
            margin: 5px 0;
            line-height: 1.4;
            color: #555;
        }
        
        .help-note {
            font-size: 10px;
            color: #888;
            text-align: center;
            margin-top: 8px;
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="canvas-container"></canvas>
    
    <div id="controls">
        <h1>âš¡ Shoe Generator Control</h1>
        
        <div class="control-group">
            <button id="press-pedal">Press Foot Pedal</button>
            <button id="reset">Reset Simulation</button>
        </div>
        
        <div class="control-group">
            <label for="speed">Compression Speed:</label>
            <input type="range" id="speed" min="1" max="10" value="5" step="1">
            <span id="speed-value">5</span>
        </div>
        
        <div class="info-display">
            <div class="info-item">
                <span class="info-label">Electrons Generated:</span>
                <span class="info-value" id="electron-count">0</span>
            </div>
            <div class="info-item">
                <span class="info-label">Motor RPM:</span>
                <span class="info-value" id="motor-rpm">0</span>
            </div>
            <div class="info-item">
                <span class="info-label">Current Output:</span>
                <span class="info-value" id="current">0 mA</span>
            </div>
        </div>
        
        <p class="help-note">DRAG to rotate â€¢ SCROLL to zoom</p>
    </div>
    
    <div id="info">
        <h3>How It Works:</h3>
        <p><strong>1. Foot Compression:</strong> Pressing the pedal pushes the rack downward.</p>
        <p><strong>2. Rack & Pinion:</strong> Linear motion converts to rotational motion via gear teeth engagement.</p>
        <p><strong>3. Motor Generation:</strong> Rotating motor generates AC electricity.</p>
        <p><strong>4. Electron Flow:</strong> Yellow spheres represent electron movement through the wire.</p>
    </div>

    <script>
        // ============================================
        // PURE CANVAS 3D ENGINE - NO DEPENDENCIES
        // ============================================
        
        const canvas = document.getElementById('canvas-container');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // ============================================
        // 3D MATH UTILITIES
        // ============================================
        
        class Vec3 {
            constructor(x = 0, y = 0, z = 0) {
                this.x = x;
                this.y = y;
                this.z = z;
            }
            
            add(v) {
                return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z);
            }
            
            sub(v) {
                return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z);
            }
            
            mul(s) {
                return new Vec3(this.x * s, this.y * s, this.z * s);
            }
            
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            }
            
            normalize() {
                const len = this.length();
                return len > 0 ? new Vec3(this.x / len, this.y / len, this.z / len) : new Vec3();
            }
            
            dot(v) {
                return this.x * v.x + this.y * v.y + this.z * v.z;
            }
            
            cross(v) {
                return new Vec3(
                    this.y * v.z - this.z * v.y,
                    this.z * v.x - this.x * v.z,
                    this.x * v.y - this.y * v.x
                );
            }
        }
        
        // ============================================
        // CAMERA & PROJECTION
        // ============================================
        
        const camera = {
            pos: new Vec3(8, 6, 8),
            target: new Vec3(0, 0.5, 0),
            fov: 75,
            near: 0.1,
            far: 1000,
            
            // Orbit controls
            theta: Math.PI / 4,
            phi: Math.PI / 4,
            radius: 12,
            
            update() {
                this.pos.x = this.target.x + this.radius * Math.sin(this.phi) * Math.cos(this.theta);
                this.pos.y = this.target.y + this.radius * Math.cos(this.phi);
                this.pos.z = this.target.z + this.radius * Math.sin(this.phi) * Math.sin(this.theta);
            }
        };
        
        function project(point) {
            // Transform to camera space
            const dir = point.sub(camera.pos);
            const forward = camera.target.sub(camera.pos).normalize();
            const right = new Vec3(0, 1, 0).cross(forward).normalize();
            const up = forward.cross(right);
            
            const x = dir.dot(right);
            const y = dir.dot(up);
            const z = dir.dot(forward);
            
            if (z <= 0.1) return null; // Behind camera
            
            // Project to screen
            const scale = (canvas.height / 2) / Math.tan((camera.fov * Math.PI / 180) / 2);
            const screenX = canvas.width / 2 + (x / z) * scale;
            const screenY = canvas.height / 2 - (y / z) * scale;
            
            return { x: screenX, y: screenY, z: z };
        }
        
        // ============================================
        // 3D SHAPES
        // ============================================
        
        function createBox(w, h, d, color) {
            return {
                type: 'box',
                width: w,
                height: h,
                depth: d,
                color: color,
                pos: new Vec3(),
                rot: new Vec3()
            };
        }
        
        function createCylinder(radius, height, color) {
            return {
                type: 'cylinder',
                radius: radius,
                height: height,
                color: color,
                pos: new Vec3(),
                rot: new Vec3()
            };
        }
        
        function createSphere(radius, color) {
            return {
                type: 'sphere',
                radius: radius,
                color: color,
                pos: new Vec3(),
                visible: true
            };
        }
        
        function rotatePoint(p, rot) {
            // Rotate around Y
            let x = p.x * Math.cos(rot.y) - p.z * Math.sin(rot.y);
            let z = p.x * Math.sin(rot.y) + p.z * Math.cos(rot.y);
            
            // Rotate around X
            let y = p.y * Math.cos(rot.x) - z * Math.sin(rot.x);
            z = p.y * Math.sin(rot.x) + z * Math.cos(rot.x);
            
            // Rotate around Z
            let x2 = x * Math.cos(rot.z) - y * Math.sin(rot.z);
            y = x * Math.sin(rot.z) + y * Math.cos(rot.z);
            
            return new Vec3(x2, y, z);
        }
        
        function drawBox(box) {
            const hw = box.width / 2, hh = box.height / 2, hd = box.depth / 2;
            const corners = [
                new Vec3(-hw, -hh, -hd), new Vec3(hw, -hh, -hd),
                new Vec3(hw, hh, -hd), new Vec3(-hw, hh, -hd),
                new Vec3(-hw, -hh, hd), new Vec3(hw, -hh, hd),
                new Vec3(hw, hh, hd), new Vec3(-hw, hh, hd)
            ];
            
            const rotated = corners.map(c => rotatePoint(c, box.rot).add(box.pos));
            const projected = rotated.map(p => project(p)).filter(p => p !== null);
            
            if (projected.length < 4) return;
            
            // Calculate average depth for sorting
            const avgZ = projected.reduce((sum, p) => sum + p.z, 0) / projected.length;
            
            // Draw faces
            const faces = [
                [0, 1, 2, 3], // front
                [4, 5, 6, 7], // back
                [0, 1, 5, 4], // bottom
                [2, 3, 7, 6], // top
                [0, 3, 7, 4], // left
                [1, 2, 6, 5]  // right
            ];
            
            faces.forEach(face => {
                ctx.beginPath();
                face.forEach((idx, i) => {
                    if (idx < projected.length) {
                        const p = projected[idx];
                        if (i === 0) ctx.moveTo(p.x, p.y);
                        else ctx.lineTo(p.x, p.y);
                    }
                });
                ctx.closePath();
                
                // Lighting based on depth
                const brightness = Math.max(0.3, Math.min(1, 1 - avgZ / 30));
                const r = parseInt(box.color.slice(1, 3), 16) * brightness;
                const g = parseInt(box.color.slice(3, 5), 16) * brightness;
                const b = parseInt(box.color.slice(5, 7), 16) * brightness;
                
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.fill();
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.lineWidth = 1;
                ctx.stroke();
            });
            
            return avgZ;
        }
        
        function drawCylinder(cyl) {
            const segments = 16;
            const radius = cyl.radius;
            const height = cyl.height;
            
            // Create top and bottom circles
            const topCircle = [];
            const bottomCircle = [];
            
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                topCircle.push(rotatePoint(new Vec3(x, height / 2, z), cyl.rot).add(cyl.pos));
                bottomCircle.push(rotatePoint(new Vec3(x, -height / 2, z), cyl.rot).add(cyl.pos));
            }
            
            const topProj = topCircle.map(p => project(p)).filter(p => p);
            const bottomProj = bottomCircle.map(p => project(p)).filter(p => p);
            
            if (topProj.length < 3 || bottomProj.length < 3) return;
            
            const avgZ = (topProj[0].z + bottomProj[0].z) / 2;
            const brightness = Math.max(0.3, Math.min(1, 1 - avgZ / 30));
            const r = parseInt(cyl.color.slice(1, 3), 16) * brightness;
            const g = parseInt(cyl.color.slice(3, 5), 16) * brightness;
            const b = parseInt(cyl.color.slice(5, 7), 16) * brightness;
            
            // Draw cylinder body
            ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
            for (let i = 0; i < segments; i++) {
                if (i < topProj.length - 1 && i < bottomProj.length - 1) {
                    ctx.beginPath();
                    ctx.moveTo(topProj[i].x, topProj[i].y);
                    ctx.lineTo(topProj[i + 1].x, topProj[i + 1].y);
                    ctx.lineTo(bottomProj[i + 1].x, bottomProj[i + 1].y);
                    ctx.lineTo(bottomProj[i].x, bottomProj[i].y);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                    ctx.stroke();
                }
            }
            
            // Draw top cap
            ctx.beginPath();
            topProj.forEach((p, i) => {
                if (i === 0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            });
            ctx.closePath();
            ctx.fillStyle = `rgb(${r * 1.2}, ${g * 1.2}, ${b * 1.2})`;
            ctx.fill();
            
            return avgZ;
        }
        
        function drawSphere(sphere) {
            if (!sphere.visible) return;
            
            const projected = project(sphere.pos);
            if (!projected) return;
            
            const screenRadius = (sphere.radius * canvas.height) / (projected.z * 2);
            
            const brightness = Math.max(0.5, Math.min(1, 1 - projected.z / 30));
            const r = parseInt(sphere.color.slice(1, 3), 16) * brightness;
            const g = parseInt(sphere.color.slice(3, 5), 16) * brightness;
            const b = parseInt(sphere.color.slice(5, 7), 16) * brightness;
            
            const gradient = ctx.createRadialGradient(
                projected.x, projected.y, 0,
                projected.x, projected.y, screenRadius
            );
            gradient.addColorStop(0, `rgb(${r * 1.5}, ${g * 1.5}, ${b * 1.5})`);
            gradient.addColorStop(1, `rgb(${r}, ${g}, ${b})`);
            
            ctx.beginPath();
            ctx.arc(projected.x, projected.y, screenRadius, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();
            
            return projected.z;
        }
        
        // ============================================
        // SCENE OBJECTS
        // ============================================
        
        const objects = [];
        
        // Base platform
        const base = createBox(6, 0.3, 6, '#2c3e50');
        base.pos = new Vec3(0, -2, 0);
        objects.push(base);
        
        // Pedal
        const pedal = createBox(2.5, 0.4, 2.5, '#34495e');
        pedal.pos = new Vec3(0, 2, 0);
        objects.push(pedal);
        
        // Rack body
        const rackBody = createBox(0.4, 3, 0.8, '#7f8c8d');
        rackBody.pos = new Vec3(-2, 0.5, 0);
        objects.push(rackBody);
        
        // Rack teeth
        const rackTeeth = [];
        for (let i = 0; i < 12; i++) {
            const tooth = createBox(0.2, 0.15, 0.8, '#7f8c8d');
            tooth.pos = new Vec3(-1.7, -1 + (i * 0.25), 0);
            objects.push(tooth);
            rackTeeth.push(tooth);
        }
        
        // Pinion gear
        const pinion = createCylinder(0.8, 0.6, '#e74c3c');
        pinion.pos = new Vec3(-0.7, 0.5, 0);
        pinion.rot = new Vec3(0, 0, Math.PI / 2);
        objects.push(pinion);
        
        // Pinion teeth
        const pinionTeeth = [];
        for (let i = 0; i < 16; i++) {
            const tooth = createBox(0.15, 0.6, 0.2, '#e74c3c');
            pinionTeeth.push(tooth);
            objects.push(tooth);
        }
        
        // Shaft
        const shaft = createCylinder(0.15, 2, '#7f8c8d');
        shaft.pos = new Vec3(0.3, 0.5, 0);
        shaft.rot = new Vec3(0, 0, Math.PI / 2);
        objects.push(shaft);
        
        // Motor
        const motor = createCylinder(0.6, 1.5, '#2c3e50');
        motor.pos = new Vec3(1.3, 0.5, 0);
        motor.rot = new Vec3(0, 0, Math.PI / 2);
        objects.push(motor);
        
        // Motor caps
        const motorCap1 = createCylinder(0.65, 0.1, '#95a5a6');
        motorCap1.pos = new Vec3(2.05, 0.5, 0);
        motorCap1.rot = new Vec3(0, 0, Math.PI / 2);
        objects.push(motorCap1);
        
        const motorCap2 = createCylinder(0.65, 0.1, '#95a5a6');
        motorCap2.pos = new Vec3(0.55, 0.5, 0);
        motorCap2.rot = new Vec3(0, 0, Math.PI / 2);
        objects.push(motorCap2);
        
        // Electrons
        const electrons = [];
        for (let i = 0; i < 20; i++) {
            const electron = createSphere(0.1, '#ffff00');
            electron.visible = false;
            electron.progress = 0;
            electron.active = false;
            objects.push(electron);
            electrons.push(electron);
        }
        
        // ============================================
        // WIRE CURVE
        // ============================================
        
        function bezierPoint(t, p0, p1, p2, p3) {
            const u = 1 - t;
            const tt = t * t;
            const uu = u * u;
            const uuu = uu * u;
            const ttt = tt * t;
            
            return p0.mul(uuu)
                .add(p1.mul(3 * uu * t))
                .add(p2.mul(3 * u * tt))
                .add(p3.mul(ttt));
        }
        
        const wirePoints = [
            new Vec3(1.3, 0.5, 0.6),
            new Vec3(1.5, 1, 1.5),
            new Vec3(2, 2, 2.5),
            new Vec3(3, 2.5, 4)
        ];
        
        function getWirePoint(t) {
            return bezierPoint(t, wirePoints[0], wirePoints[1], wirePoints[2], wirePoints[3]);
        }
        
        // ============================================
        // ANIMATION STATE
        // ============================================
        
        const state = {
            pedalPressed: false,
            pedalY: 2,
            targetPedalY: 2,
            rackY: 0.5,
            pinionRotation: 0,
            motorRotation: 0,
            motorSpeed: 0,
            compressionSpeed: 5,
            electronCount: 0,
            activeElectrons: 0
        };
        
        // ============================================
        // PHYSICS
        // ============================================
        
        const pinionRadius = 0.8;
        const gearRatio = 5;
        
        function updatePhysics() {
            const lerpFactor = 0.1 * state.compressionSpeed;
            state.pedalY += (state.targetPedalY - state.pedalY) * lerpFactor;
            pedal.pos.y = state.pedalY;
            
            const rackDisplacement = 2 - state.pedalY;
            state.rackY = 0.5 - rackDisplacement;
            rackBody.pos.y = state.rackY;
            
            rackTeeth.forEach((tooth, i) => {
                tooth.pos.y = state.rackY - 1.5 + (i * 0.25);
            });
            
            const linearDistance = rackDisplacement;
            state.pinionRotation = linearDistance / pinionRadius;
            pinion.rot.y = state.pinionRotation;
            
            // Update pinion teeth positions
            pinionTeeth.forEach((tooth, i) => {
                const angle = (i / 16) * Math.PI * 2 + state.pinionRotation;
                const offsetX = Math.cos(angle) * 0.9;
                const offsetZ = Math.sin(angle) * 0.9;
                tooth.pos = new Vec3(-0.7 + offsetX, 0.5, offsetZ);
                tooth.rot = new Vec3(0, angle, Math.PI / 2);
            });
            
            state.motorRotation = state.pinionRotation * gearRatio;
            motor.rot.x = state.motorRotation;
            
            const rotationsPerFrame = Math.abs(state.motorSpeed);
            const rpm = Math.round(rotationsPerFrame * 60 * 60);
            const current = Math.round(Math.abs(state.motorSpeed) * 100);
            
            document.getElementById('motor-rpm').textContent = rpm;
            document.getElementById('current').textContent = current + ' mA';
        }
        
        function updateElectrons(deltaTime) {
            if (state.motorSpeed > 0.001 && state.activeElectrons < 20) {
                const spawnRate = state.motorSpeed * 10;
                if (Math.random() < spawnRate * deltaTime) {
                    const electron = electrons.find(e => !e.active);
                    if (electron) {
                        electron.active = true;
                        electron.progress = 0;
                        electron.visible = true;
                        state.activeElectrons++;
                        state.electronCount++;
                        document.getElementById('electron-count').textContent = state.electronCount;
                    }
                }
            }
            
            electrons.forEach(e => {
                if (!e.active) return;
                
                e.progress += state.motorSpeed * 0.5 * deltaTime * 60;
                
                if (e.progress >= 1) {
                    e.active = false;
                    e.visible = false;
                    state.activeElectrons--;
                } else {
                    e.pos = getWirePoint(e.progress);
                }
            });
        }
        
        // ============================================
        // MOUSE CONTROLS
        // ============================================
        
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const deltaX = e.clientX - lastMouseX;
            const deltaY = e.clientY - lastMouseY;
            
            camera.theta -= deltaX * 0.01;
            camera.phi = Math.max(0.1, Math.min(Math.PI - 0.1, camera.phi - deltaY * 0.01));
            camera.update();
            
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });
        
        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });
        
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            camera.radius = Math.max(5, Math.min(30, camera.radius + e.deltaY * 0.01));
            camera.update();
        });
        
        // ============================================
        // BUTTON CONTROLS
        // ============================================
        
        document.getElementById('press-pedal').addEventListener('click', () => {
            if (state.pedalPressed) {
                state.targetPedalY = 2;
                state.pedalPressed = false;
                document.getElementById('press-pedal').textContent = 'Press Foot Pedal';
            } else {
                state.targetPedalY = 0.2;
                state.pedalPressed = true;
                document.getElementById('press-pedal').textContent = 'Release Pedal';
            }
        });
        
        document.getElementById('reset').addEventListener('click', () => {
            state.pedalPressed = false;
            state.targetPedalY = 2;
            state.pedalY = 2;
            state.rackY = 0.5;
            state.pinionRotation = 0;
            state.motorRotation = 0;
            state.motorSpeed = 0;
            state.electronCount = 0;
            state.activeElectrons = 0;
            
            electrons.forEach(e => {
                e.active = false;
                e.visible = false;
                e.progress = 0;
            });
            
            document.getElementById('electron-count').textContent = '0';
            document.getElementById('motor-rpm').textContent = '0';
            document.getElementById('current').textContent = '0 mA';
            document.getElementById('press-pedal').textContent = 'Press Foot Pedal';
        });
        
        document.getElementById('speed').addEventListener('input', (e) => {
            state.compressionSpeed = parseInt(e.target.value);
            document.getElementById('speed-value').textContent = e.target.value;
        });
        
        // ============================================
        // RENDER LOOP
        // ============================================
        
        let lastTime = Date.now();
        
        function render() {
            const currentTime = Date.now();
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            const oldMotorRot = motor.rot.x;
            updatePhysics();
            state.motorSpeed = Math.abs(motor.rot.x - oldMotorRot);
            
            if (!state.pedalPressed && state.motorSpeed > 0.001) {
                state.motorSpeed *= 0.95;
            } else if (!state.pedalPressed) {
                state.motorSpeed = 0;
            }
            
            updateElectrons(deltaTime);
            
            // Clear canvas
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Sort objects by depth (painter's algorithm)
            const renderList = objects
                .map(obj => ({ obj, depth: obj.pos.sub(camera.pos).length() }))
                .sort((a, b) => b.depth - a.depth);
            
            // Render all objects
            renderList.forEach(({ obj }) => {
                if (obj.type === 'box') drawBox(obj);
                else if (obj.type === 'cylinder') drawCylinder(obj);
                else if (obj.type === 'sphere') drawSphere(obj);
            });
            
            requestAnimationFrame(render);
        }
        
        // ============================================
        // WINDOW RESIZE
        // ============================================
        
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
        
        // Initialize
        camera.update();
        render();
        
        console.log('ðŸ”Œ Shoe Generator - Zero Dependency Version Loaded!');
    </script>
</body>
</html>