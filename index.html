<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Mechanical Engineering Sim - Real Physics</title>
    <style>
        body { margin: 0; background: #111; font-family: 'Courier New', Courier, monospace; overflow: hidden; }
        #ui { position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.8); color: #0f0; padding: 20px; border: 1px solid #0f0; border-radius: 5px; z-index: 10; width: 300px; }
        button { width: 100%; padding: 15px; background: #0f0; color: #000; border: none; font-weight: bold; cursor: pointer; margin-bottom: 10px; }
        .stat { display: flex; justify-content: space-between; margin-bottom: 5px; }
    </style>
</head>
<body>

    <div id="ui">
        <h2>ENGINEERING SIM</h2>
        <button id="pedal">STEP ON PEDAL</button>
        <div class="stat"><span>RACK POS:</span> <span id="rack-y">0.00</span></div>
        <div class="stat"><span>PINION ROT:</span> <span id="pinion-deg">0.0°</span></div>
        <div class="stat"><span>MOTOR RPM:</span> <span id="rpm">0</span></div>
        <p><small>> DRAG TO ROTATE VIEW</small></p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- 1. SCENE SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(5, 4, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        
        // Lighting
        const sun = new THREE.DirectionalLight(0xffffff, 1.5);
        sun.position.set(10, 10, 10);
        scene.add(sun);
        scene.add(new THREE.AmbientLight(0xffffff, 0.3));

        // --- 2. MATERIALS ---
        const matSteel = new THREE.MeshStandardMaterial({ color: 0x777777, metalness: 0.8, roughness: 0.2 });
        const matBrass = new THREE.MeshStandardMaterial({ color: 0xb5a642, metalness: 0.7, roughness: 0.3 });
        const matMotor = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.9 });

        // --- 3. THE RACK (Vertical Force) ---
        const rackGroup = new THREE.Group();
        const rackBody = new THREE.Mesh(new THREE.BoxGeometry(0.3, 4, 0.4), matSteel);
        rackGroup.add(rackBody);

        // REAL TEETH: Orientated to face the motor side (+X direction)
        for(let i=0; i<16; i++) {
            const tooth = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.08, 0.3), matSteel);
            tooth.position.set(0.18, -1.8 + (i * 0.25), 0);
            rackGroup.add(tooth);
        }
        rackGroup.position.set(-1, 2, 0); // Offset to mesh
        scene.add(rackGroup);

        // --- 4. THE PINION & MOTOR (Horizontal Axis) ---
        // Both exist on the X-axis to rotate the same way
        const transmissionGroup = new THREE.Group();

        // The Gear (Pinion)
        const gearRadius = 0.75;
        const gearGroup = new THREE.Group();
        const gearCore = new THREE.Mesh(new THREE.CylinderGeometry(gearRadius, gearRadius, 0.3, 32), matBrass);
        gearCore.rotation.z = Math.PI / 2; // Lay flat on X-axis
        gearGroup.add(gearCore);

        // Meshing Teeth
        for(let i=0; i<12; i++) {
            const angle = (i/12) * Math.PI * 2;
            const tooth = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.3, 0.1), matBrass);
            tooth.position.set(0, Math.cos(angle)*gearRadius, Math.sin(angle)*gearRadius);
            tooth.rotation.x = -angle;
            gearGroup.add(tooth);
        }
        transmissionGroup.add(gearGroup);

        // The Motor (Attached to the same shaft)
        const motor = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 1.2, 32), matMotor);
        motor.rotation.z = Math.PI / 2;
        motor.position.x = 1.0; // Pushed along X-axis
        transmissionGroup.add(motor);
        
        // Shaft connecting them
        const shaft = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 2, 16), matSteel);
        shaft.rotation.z = Math.PI / 2;
        shaft.position.x = 0.5;
        transmissionGroup.add(shaft);

        transmissionGroup.position.set(-0.2, 1, 0);
        scene.add(transmissionGroup);

        // --- 5. PHYSICS ENGINE ---
        let rackY = 2;
        let targetY = 2;
        const pedal = document.getElementById('pedal');

        pedal.onmousedown = () => targetY = 0;
        pedal.onmouseup = () => targetY = 2;

        function animate() {
            requestAnimationFrame(animate);

            // Smooth linear interpolation (Lerp)
            const oldY = rackY;
            rackY += (targetY - rackY) * 0.1;
            rackGroup.position.y = rackY;

            // REAL PHYSICS CALCULATION
            // Distance moved = Rack Delta
            const deltaY = oldY - rackY;
            
            // Angle = Distance / Radius
            const rotationAngle = deltaY / gearRadius;
            
            // Apply rotation to the entire transmission (Gear + Shaft + Motor)
            transmissionGroup.rotation.x += rotationAngle;

            // UI Updates
            document.getElementById('rack-y').innerText = rackY.toFixed(2);
            document.getElementById('pinion-deg').innerText = (transmissionGroup.rotation.x * 57.29).toFixed(1) + "°";
            document.getElementById('rpm').innerText = Math.round(Math.abs(deltaY) * 6000);

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        // Handle window resizing
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>